####################################################################################################################################################################################
2 БИТЫ, БИТОВЫЕ ОПЕРАЦИИ, ПОЛНЫЙ ПЕРЕБОР, ТИПЫ В С++.
####################################################################################################################################################################################
Условие Фоно - никакое кодовое слово не может быть началом другого кодового слова.
A - 00
B - 01
C - 10
D - 11 
Всего: 2**2 состояний.

бит - мера информации в одном двоичном разряде.
байт - ячейка памяти, у которой есть собственный адрес.

Если хотим: 2**N > M (алфавит = пунктуация, буквы, цифры и т.д.) --> точно хватит 2**7 = 128 состояний - это ASCII. Но может быть и другая кодировка.

Пусть в компьютере двухбитные байты.
У т-триггера - приходит сигнал при спуске сигнала (двоичный счётчик).
Неравномерное кодирование, для которого актуально условие Фоно, встречается в системе команд ЦИСК процессоров (itel). Неравномерное кодирование -> UTF-8.

Двоичную систему можно рассматривать как двоичное кодирование. Если есть 2 бит ячейка, то в ней можно закодировать только:
0 - 00
1 - 01
2 - 10
3 - 11
Такая структура напоминает кольцо вычетов по модулю 4. У нас: 2 * 2 = 4, но 4 это 4 % 4 = 0. 3*3 = 9%4 = 1. Это переполнения.
2 байта -> 2 ** 16 = 65536 состояний. Т.е. числа от 0 до 65535.
1 байт -> 2 ** 8 = 256 состояний. Т.е. числа от 0 до 255 (кстати, 255 = 11111111)
Каждый байт кодируется двумя 16-иричными цифрами, от 00 до FF (FF = 1111 1111 = 255). Это удобно, так как:
1010_2 = A_16 = 10
1011_2 = B_16 = 11
С = 12
D = 13
E = 14
F = 15

Аримфетика:
1)
001010 + 001100 = 010110
2) 
010110 * 110 = 0100,0010 = 64 + 2 = 66.

В языке C char и int содержат неизвестное количество байт. Чаще всего 2 или 4 юайта (в большинстве - 4 байта).
Управление длинной: short, long
Знак: signed, unsigned
unsigned long long int x; - объявлене одной переменной -> рекомендуют от такой системы избавляться, слишком непонятно.
Рекомендуемое: int8_t x; uint16_t y; int64_t z;

Битовые операции:
1) Битовое "и": &
01010101 - x
11000011 - mask
--------
01000001
Всегда 0, кроме 1 & 1 = 1.
Такую операцию интересно называть "наложение маски": x накладывается на mask -> 01000001. Маска позволяет "высветить" нужный бит.
2) Битовое "или": |
0 | 0 = 0, 0 | 1 = 1, 1 | 0 = 1, 1 | 1 = 1.
10001
00110
-----
10111 - "выстивили" 2 бита, 2й и 3й.
3) Исключающее или (xor): ^
0 | 0 = 0, 0 | 1 = 1, 1 | 0 = 1, 1 | 1 = 0.
Используется в криптографии.
01010101 - x
11001011 - key
--------
10011110 - x* - закодировалось.
Наложим повторно:
01010101 - x*
11001011 - key
--------
10011110 - x
4) Битовая инверсия: ~a.
Вместо 0 -> 1, 1 -> 0.

Логический тип bool:
Раньше не было boola -> вместо них 1 и 0, т.е. z = x > y  - это int.
Логические операции: &&, ||.
Можно импортировать <ciso646>, которое позволяет использовать and or not.
Есть тип bool:
bool  flag;
Тут можно использовать & и ||.

bool flag = false;
uint32_t x;
cin >> x;
while (x != 0) {
    flag = (x%10 == 7) || flag
    x = x /10;
}
cout << flag;

Явное преобразование типов: (double(x) / y) - будет дробным.


ПОЛНЫЙ ПЕРЕБОР (bruteforce):

1) тест простоты: существуют алгоритмы для быстрого решения, но сложно пишутся.
bool flag = true
for (int d = 2; d < x; ++d) {
    if (x % d == 0) {
        flag = false;
        break;
    }
}
2) разложение на множители: невозможно разложить быстро, используется в банках, RSA.
int d = 2;
while (x != 1){
    if (x % d == 0) {
        cout << d << endl;
        x = x / d;
    }
    else {
        d++;
    }
}
